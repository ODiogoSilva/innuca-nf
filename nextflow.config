//                   USER DEFINED PARAMETERS FOR INNUCA PIPELINE             //
///////////////////////////////////////////////////////////////////////////////
params {

    // GENERAL PARAMS //
    // Path and expression for paired-end FastQ files
    fastq_files = "data/*_{1,2}.*"
    // Genome size estimate for samples
    genome_size = 2.1
    // Minimum coverage
    min_coverage = 15

    // FASTQC //
    // Adapters file path
    adapters = 'None'

    // TRIMMOMATIC //
    // Perform a sliding window trimming, cutting once the average quality
    // within the window falls below a threshold
    trim_sliding_window = '5:20'
    // Cut bases off the start of a read, if below a threshold quality
    trim_leading = '3'
    // Cut bases off the end of a read, if below a threshold quality
    trim_trailing = '3'
    // Drop the read if it is below a specified length
    tim_min_length = '55'

    // SPADES //
    // The minimum number of reads to consider an edge in the de Bruijn
    // graph during the assembly.
    spades_min_coverage = '2'
    // Minimum contigs K-mer coverage. After assembly only keep contigs with
    // reported k-mer coverage equal or above this value
    spades_min_kmer_coverage = '2'
    // If 'auto' the SPAdes k-mer lengths will be determined from the maximum
    // read length of each assembly. If 'default', SPAdes will use the default
    // k-mer lengths. Otherwise, specify the k-mer lengths manually like:
    // '55 77 99 113 127'
    spades_kmers = 'auto'
    // Filter SPAdes contigs for length greater or equal than this value
    spades_min_contig_len = 200
    // Maximum number of contigs per 1.5 Mb of expected genome size
    spades_max_contigs = 100

    // ASSEMBLY MAPPING //
    // In auto, the default minimum coverage for each assembled contig is
    // 1/3 of the assembly mean coverage or 10x, if the mean coverage is below
    // 10x.
    min_assembly_coverage = 'auto'

    // RUN TIME OPTIONS //
    // Specify at which point (process) the pipeline should end. This can
    // be useful when testing some part of the pipeline without running it
    // completely. Leave empty to run the entire pipeline
    stop_at = ""

}

//                         PROCESS SPECIFIC OPTIONS                          //
///////////////////////////////////////////////////////////////////////////////

process {

    echo = true

    // DOCKER CONTAINERS //
    $fastqc.container = 'odiogosilva/fastqc:0.11.5'
    $trimmomatic.container = 'odiogosilva/trimmomatic'
    $spades.container = 'odiogosilva/spades:3.11.0'
    $assembly_mapping.container = 'odiogosilva/bowtie2_samtools'
    $assembly_mapping_coverage.container = 'odiogosilva/bowtie2_samtools'
    $process_assembly_mapping.container = 'odiogosilva/bowtie2_samtools'
    $pilon.container = 'odiogosilva/pilon:1.22'
    $mlst.container = 'odiogosilva/mlst'

    // CPU USAGE PER PROCESS //
    $fastqc.cpus = 2
    $trimmomatic.cpus = 2
    $spades.cpus = 2
    $assembly_mapping.cpus = 2
    $pilon.cpus = 2

}

executor {
  $local {
      cpus = 4
  }
}

profiles {

    standard {
        docker.enabled = true
    }

    sing {
        singularity.enabled = true

        // Replace container destination for singularity images
        process.$fastqc.container = 'docker://odiogosilva/fastqc:0.11.5'
        process.$trimmomatic.container = 'docker://odiogosilva/trimmomatic'
        process.$spades.container = 'docker://odiogosilva/spades:3.11.0'
        process.$assembly_mapping.container = 'docker://odiogosilva/bowtie2_samtools'
        process.$assembly_mapping_coverage.container = 'docker://odiogosilva/bowtie2_samtools'
        process.$process_assembly_mapping.container = 'docker://odiogosilva/bowtie2_samtools'
        process.$pilon.container = 'docker://odiogosilva/pilon:1.22'
        process.$mlst.container = 'docker://odiogosilva/mlst'
        process.$abricate.container = 'docker://ummidock/abricate'
    }

    slurm {

        // Settings for SLURM cluster executor
        process.executor = "slurm"
        shifter.enabled = true

        process {

            scratch = true

            // DOCKER CONTAINERS //
            $fastqc.container = 'ummidock/fastqc:0.11.5'
            $trimmomatic.container = 'ummidock/trimmomatic:0.36'
            $spades.container = 'ummidock/spades:3.11.0'
            $assembly_mapping.container = 'ummidock/bowtie2_samtools:latest'
            $assembly_mapping_coverage.container = 'ummidock/bowtie2_samtools:latest'
            $process_assembly_mapping.container = 'ummidock/bowtie2_samtools:latest'
            $pilon.container = 'ummidock/pilon:1.22'
            $mlst.container = 'ummidock/mlst:latest'

            // CPU USAGE PER PROCESS //
            $fastqc.cpus = 1
            $trimmomatic.cpus = 1
            $spades.cpus = 2
            $assembly_mapping.cpus = 1
            $pilon.cpus = 1

            // MEMORY USAGE PER PROCESS //
            // general memory usage
            memory = "4GB"

            // Process specific memory usage
            $spades.memory = "10GB"
            $trimmomatic.memory = "10GB"
            $pilon.memory = "8GB"

        }


    }

}

manifest {
    homePage = 'https://github.com/ODiogoSilva/innuca-nf'
    description = 'A nextflow implementation of INNUENDO quality control of reads, de novo assembly and contigs quality assessment, and possible contamination search'
    mainScript = 'innuca.nf'
}